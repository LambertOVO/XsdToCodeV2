using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.ComponentModel;

using Microsoft.CSharp;
using System.IO;
using System.Diagnostics;

using Microsoft.VisualBasic;

using Xsd2.Capitalizers;

namespace Xsd2
{
    public class XsdCodeGenerator
    {
        public XsdCodeGeneratorOptions Options { get; set; }
        public Action<CodeNamespace, XmlSchema> OnValidateGeneratedCode { get; set; }

        XmlSchemas xsds = new XmlSchemas();
        HashSet<XmlSchema> importedSchemas = new HashSet<XmlSchema>();

        public void Generate(IList<String> schemas, TextWriter output)
        {
            if (Options == null)
                Options = new XsdCodeGeneratorOptions
                {
                    UseLists = true,
                    PropertyNameCapitalizer = new FirstCharacterCapitalizer(),
                    StripDebuggerStepThroughAttribute = true,
                    OutputNamespace = "Xsd2",
                    UseNullableTypes = true
                };

            if (Options.Imports != null)
            {
                foreach (var import in Options.Imports)
                {
                    if (File.Exists(import))
                    {
                        ImportImportedSchema(import);
                    }
                    else if (Directory.Exists(import))
                    {
                        foreach (var file in Directory.GetFiles("*.xsd"))
                            ImportImportedSchema(file);
                    }
                    else
                    {
                        throw new InvalidOperationException(String.Format("Import '{0}' is not a file nor a directory.", import));
                    }
                }
            }

            var inputs = new List<XmlSchema>();

            foreach (var path in schemas)
            {
                using (var r = File.OpenText(path))
                {
                    XmlSchema xsd = XmlSchema.Read(r, null);
                    xsds.Add(xsd);
                    inputs.Add(xsd);
                }
            }
            
            xsds.Compile(null, true);
            
            XmlSchemaImporter schemaImporter = new XmlSchemaImporter(xsds);
          

            // create the codedom
            CodeNamespace codeNamespace = new CodeNamespace(Options.OutputNamespace);
            XmlCodeExporter codeExporter = new XmlCodeExporter(codeNamespace);

            List<XmlTypeMapping> maps = new List<XmlTypeMapping>();
            foreach (var xsd in inputs)
                foreach (XmlSchemaElement schemaElement in xsd.Elements.Values)
                {
                    if (!ElementBelongsToImportedSchema(schemaElement))
                        maps.Add(schemaImporter.ImportTypeMapping(schemaElement.QualifiedName));
                }


            foreach (var xsd in inputs)
                foreach (XmlSchemaComplexType schemaElement in xsd.Items.OfType<XmlSchemaComplexType>())
                {
                    maps.Add(schemaImporter.ImportSchemaType(schemaElement.QualifiedName));
                }

            foreach (var xsd in inputs)
                foreach (XmlSchemaSimpleType schemaElement in xsd.Items.OfType<XmlSchemaSimpleType>())
                {
                    maps.Add(schemaImporter.ImportSchemaType(schemaElement.QualifiedName));
                }

            foreach (XmlTypeMapping map in maps)
            {
                codeExporter.ExportTypeMapping(map);
            }

            foreach (var xsd in inputs)
                ImproveCodeDom(codeNamespace, xsd);

            if (OnValidateGeneratedCode != null)
                foreach (var xsd in inputs)
                    OnValidateGeneratedCode(codeNamespace, xsd);

            // Check for invalid characters in identifiers
            CodeGenerator.ValidateIdentifiers(codeNamespace);

            if (Options.WriteFileHeader)
            {
                // output the header
                string lineCommentCharacter;
                switch (Options.Language)
                {
                    case XsdCodeGeneratorOutputLanguage.VB:
                        lineCommentCharacter = "'";
                        break;
                    default:
                        lineCommentCharacter = "//";
                        break;
                }

                output.WriteLine("{0}------------------------------------------------------------------------------", lineCommentCharacter);
                output.WriteLine("{0} <auto-generated>", lineCommentCharacter);
                output.WriteLine("{0}     This code has been generated by a tool.", lineCommentCharacter);
                output.WriteLine("{0} </auto-generated>", lineCommentCharacter);
                output.WriteLine("{0}------------------------------------------------------------------------------", lineCommentCharacter);
                output.WriteLine();
            }

            // output the C# code
            CodeDomProvider codeProvider;
            switch (Options.Language)
            {
                case XsdCodeGeneratorOutputLanguage.VB:
                    codeProvider = new VBCodeProvider();
                    break;
                default:
                    codeProvider = new CSharpCodeProvider();
                    break;
            }

            codeProvider.GenerateCodeFromNamespace(codeNamespace, output, new CodeGeneratorOptions());
        }

        private void ImportImportedSchema(string schemaFilePath)
        {
            using (var s = File.OpenRead(schemaFilePath))
            {
                var importedSchema = XmlSchema.Read(s, null);
                xsds.Add(importedSchema);
                importedSchemas.Add(importedSchema);
            }
        }

        private bool ElementBelongsToImportedSchema(XmlSchemaElement element)
        {
            var node = element.Parent;
            while (node != null)
            {
                if (node is XmlSchema)
                {
                    var schema = (XmlSchema)node;
                    return importedSchemas.Contains(schema);
                }
                else
                    node = node.Parent;
            }
            return false;
        }

        /// <summary>
        /// Shamelessly taken from Xsd2Code project
        /// </summary>       
        private bool ContainsTypeName(XmlSchema schema, CodeTypeDeclaration type)
        {
            //TODO: Does not work for combined anonymous types 
            //fallback: Check if the namespace attribute of the type equals the namespace of the file.
            //first, find the XmlType attribute.
            var ns = ExtractNamespace(type);
            if (ns!=null && ns != schema.TargetNamespace)
                return false;

            if (!Options.ExcludeImportedTypesByNameAndNamespace)
                return true;

            foreach (var item in schema.Items)
            {
                var complexItem = item as XmlSchemaComplexType;
                if (complexItem != null)
                {
                    if (complexItem.Name == type.Name)
                    {
                        return true;
                    }
                }

                var simpleItem = item as XmlSchemaSimpleType;
                if (simpleItem != null)
                {
                    if (simpleItem.Name == type.Name)
                    {
                        return true;
                    }
                }


                var elementItem = item as XmlSchemaElement;
                if (elementItem != null)
                {
                    if (elementItem.Name == type.Name)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        private String ExtractNamespace(CodeTypeDeclaration type)
        {
            foreach (CodeAttributeDeclaration attribute in type.CustomAttributes)
            {
                if (attribute.Name == "System.Xml.Serialization.XmlTypeAttribute")
                {
                    foreach (CodeAttributeArgument argument in attribute.Arguments)
                    {
                        if (argument.Name == "Namespace")
                        {
                           return (string)((CodePrimitiveExpression)argument.Value).Value;
                        }
                    }
                }
            }

            return null;
        }

        private void ImproveCodeDom(CodeNamespace codeNamespace, XmlSchema schema)
        {
            var nonElementAttributes = new HashSet<string>(new[]
            {
                "System.Xml.Serialization.XmlAttributeAttribute",
                "System.Xml.Serialization.XmlIgnoreAttribute",
                "System.Xml.Serialization.XmlTextAttribute",
            });

            var nullValue = new CodePrimitiveExpression();

            codeNamespace.Imports.Add(new CodeNamespaceImport("System"));
            codeNamespace.Imports.Add(new CodeNamespaceImport("System.Collections.Generic"));

            if (Options.UsingNamespaces != null)
                foreach (var ns in Options.UsingNamespaces)
                    codeNamespace.Imports.Add(new CodeNamespaceImport(ns));

            var neverBrowsableAttribute = new CodeAttributeDeclaration("System.ComponentModel.EditorBrowsable",
                new CodeAttributeArgument(new CodeFieldReferenceExpression(new CodeTypeReferenceExpression("System.ComponentModel.EditorBrowsableState"), "Never")));

            var removedTypes = new List<CodeTypeDeclaration>();

            foreach (CodeTypeDeclaration codeType in codeNamespace.Types)
            {
                if (Options.ExcludeImportedTypes && Options.Imports != null && Options.Imports.Count > 0)
                    if (!ContainsTypeName(schema, codeType))
                    {
                        removedTypes.Add(codeType);
                        continue;
                    }

                var attributesToRemove = new HashSet<CodeAttributeDeclaration>();
                if (Options.StripDebuggerStepThroughAttribute)
                {
                    foreach (CodeAttributeDeclaration att in codeType.CustomAttributes)
                    {
                        if (att.Name == "System.Diagnostics.DebuggerStepThroughAttribute")
                        {
                            attributesToRemove.Add(att);
                            break;
                        }
                    }
                }

                if (Options.StripPclIncompatibleAttributes)
                {
                    foreach (CodeAttributeDeclaration att in codeType.CustomAttributes)
                    {
                        switch (att.Name)
                        {
                            case "System.SerializableAttribute":
                            case "System.ComponentModel.DesignerCategoryAttribute":
                                attributesToRemove.Add(att);
                                break;
                        }
                    }
                }

                foreach (var att in attributesToRemove)
                {
                    codeType.CustomAttributes.Remove(att);
                }

                var members = new Dictionary<string, CodeTypeMember>();
                foreach (CodeTypeMember member in codeType.Members)
                    members[member.Name] = member;

                if (Options.EnableDataBinding && codeType.IsClass && codeType.BaseTypes.Count == 0)
                {
                    codeType.BaseTypes.Add(typeof(object));
                    codeType.BaseTypes.Add(typeof(INotifyPropertyChanged));

                    codeType.Members.Add(new CodeMemberEvent()
                    {
                        Name = "PropertyChanged",
                        ImplementationTypes = { typeof(INotifyPropertyChanged) },
                        Attributes = MemberAttributes.Public,
                        Type = new CodeTypeReference(typeof(PropertyChangedEventHandler))
                    });

                    codeType.Members.Add(new CodeMemberMethod()
                    {
                        Name = "RaisePropertyChanged",
                        Attributes = MemberAttributes.Family | MemberAttributes.Final,
                        Parameters =
                        {
                            new CodeParameterDeclarationExpression(typeof(string), "propertyName")
                        },
                        Statements =
                        {
                            new CodeVariableDeclarationStatement(typeof(PropertyChangedEventHandler), "propertyChanged",
                                new CodeEventReferenceExpression(new CodeThisReferenceExpression(), "PropertyChanged")),
                            new CodeConditionStatement(new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression("propertyChanged"), CodeBinaryOperatorType.IdentityInequality, nullValue),
                                new CodeExpressionStatement(new CodeDelegateInvokeExpression(new CodeVariableReferenceExpression("propertyChanged"),
                                    new CodeThisReferenceExpression(),
                                    new CodeObjectCreateExpression(typeof(PropertyChangedEventArgs), new CodeArgumentReferenceExpression("propertyName")))))
                        }
                    });
                }

                bool mixedContentDetected = Options.MixedContent && members.ContainsKey("textField") && members.ContainsKey("itemsField");

                var orderIndex = 0;
                foreach (CodeTypeMember member in members.Values)
                {
                    if (member is CodeMemberField)
                    {
                        CodeMemberField field = (CodeMemberField)member;

                        if (mixedContentDetected)
                        {
                            switch (field.Name)
                            {
                                case "textField":
                                    codeType.Members.Remove(member);
                                    continue;
                                case "itemsField":
                                    field.Type = new CodeTypeReference(typeof(object[]));
                                    break;
                            }
                        }

                        if (Options.UseLists && field.Type.ArrayRank > 0)
                        {
                            CodeTypeReference type = new CodeTypeReference();
                            type.BaseType = "List<" + field.Type.BaseType + ">";
                            field.Type = type;
                        }

                        if (codeType.IsEnum && Options.EnumValueCapitalizer != null)
                        {
                            var newName = Options.EnumValueCapitalizer.Capitalize(member.Name);
                            if (newName != member.Name)
                            {
                                member.CustomAttributes.Add(new CodeAttributeDeclaration("System.Xml.Serialization.XmlEnumAttribute", new CodeAttributeArgument { Name = "", Value = new CodePrimitiveExpression(member.Name) }));
                                member.Name = newName;
                            }
                        }
                    }

                    if (member is CodeMemberProperty)
                    {
                        CodeMemberProperty property = (CodeMemberProperty)member;

                        // Is this "*Specified" property part of a "propertyName" and "propertyNameSpecified" combination?
                        var isSpecifiedProperty = property.Name.EndsWith("Specified") && members.ContainsKey(property.Name.Substring(0, property.Name.Length - 9));

                        if (mixedContentDetected)
                        {
                            switch (property.Name)
                            {
                                case "Text":
                                    codeType.Members.Remove(member);
                                    continue;
                                case "Items":
                                    property.Type = new CodeTypeReference(typeof(object[]));
                                    property.CustomAttributes.Add(new CodeAttributeDeclaration("System.Xml.Serialization.XmlTextAttribute", new CodeAttributeArgument { Name = "", Value = new CodeTypeOfExpression(new CodeTypeReference(typeof(string))) }));
                                    break;
                            }
                        }

                        if (Options.UseLists && property.Type.ArrayRank > 0)
                        {
                            CodeTypeReference type = new CodeTypeReference();
                            type.BaseType = "List<" + property.Type.BaseType + ">";
                            property.Type = type;
                        }

                        bool capitalizeProperty;
                        if (!isSpecifiedProperty)
                        {
                            if (Options.UseNullableTypes)
                            {
                                var fieldName = GetFieldName(property.Name, "Field");
                                CodeTypeMember specified;
                                if (members.TryGetValue(property.Name + "Specified", out specified))
                                {
                                    var nullableProperty = new CodeMemberProperty
                                    {
                                        Name = property.Name,
                                        Type = new CodeTypeReference(typeof(Nullable<>)) {TypeArguments = { property.Type.BaseType } },
                                        HasGet = true,
                                        HasSet = true,
                                        Attributes = MemberAttributes.Public | MemberAttributes.Final
                                    };

                                    nullableProperty.GetStatements.Add(
                                        new CodeConditionStatement(new CodeVariableReferenceExpression(fieldName + "Specified"),
                                            new CodeStatement[] {new CodeMethodReturnStatement(new CodeVariableReferenceExpression(fieldName))},
                                            new CodeStatement[] {new CodeMethodReturnStatement(new CodePrimitiveExpression())}
                                        ));

                                    nullableProperty.SetStatements.Add(
                                        new CodeConditionStatement(new CodeBinaryOperatorExpression(new CodePropertySetValueReferenceExpression(), CodeBinaryOperatorType.IdentityInequality, nullValue),
                                            new CodeStatement[]
                                            {
                                                new CodeAssignStatement(new CodeVariableReferenceExpression(fieldName + "Specified"),
                                                    new CodePrimitiveExpression(true)),
                                                new CodeAssignStatement(new CodeVariableReferenceExpression(fieldName),
                                                    new CodePropertyReferenceExpression(new CodePropertySetValueReferenceExpression(), "Value")),
                                            },
                                            new CodeStatement[]
                                            {
                                                new CodeAssignStatement(
                                                    new CodeVariableReferenceExpression(fieldName + "Specified"),
                                                    new CodePrimitiveExpression(false)),
                                            }
                                        ));

                                    nullableProperty.CustomAttributes.Add(new CodeAttributeDeclaration
                                    {
                                        Name = "System.Xml.Serialization.XmlIgnoreAttribute"
                                    });

                                    codeType.Members.Add(nullableProperty);

                                    foreach (CodeAttributeDeclaration attribute in property.CustomAttributes)
                                        if (attribute.Name == "System.Xml.Serialization.XmlAttributeAttribute")
                                            attribute.Arguments.Add(new CodeAttributeArgument
                                            {
                                                Name = "AttributeName",
                                                Value = new CodePrimitiveExpression(property.Name)
                                            });

                                    property.Name = "_" + property.Name;
                                    specified.Name = "_" + specified.Name;

                                    if (Options.HideUnderlyingNullableProperties)
                                    {
                                        property.CustomAttributes.Add(neverBrowsableAttribute);
                                        specified.CustomAttributes.Add(neverBrowsableAttribute);
                                    }

                                    property = nullableProperty;
                                }
                            }

                            if (Options.PreserveOrder)
                            {
                                if (!property.CustomAttributes.Cast<CodeAttributeDeclaration>().Any(x => nonElementAttributes.Contains(x.Name)))
                                {
                                    var elementAttributes = property
                                        .CustomAttributes.Cast<CodeAttributeDeclaration>()
                                        .Where(x => x.Name == "System.Xml.Serialization.XmlElementAttribute")
                                        .ToList();
                                    if (elementAttributes.Count == 0)
                                    {
                                        var elementAttribute = new CodeAttributeDeclaration("System.Xml.Serialization.XmlElementAttribute");
                                        property.CustomAttributes.Add(elementAttribute);
                                        elementAttributes.Add(elementAttribute);
                                    }

                                    foreach (var elementAttribute in elementAttributes)
                                    {
                                        elementAttribute.Arguments.Add(new CodeAttributeArgument("Order", new CodePrimitiveExpression(orderIndex)));
                                    }

                                    orderIndex += 1;
                                }
                            }

                            if (Options.EnableDataBinding)
                            {
                                property.SetStatements.Add(new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "RaisePropertyChanged", new CodePrimitiveExpression(property.Name)));
                            }

                            capitalizeProperty = Options.PropertyNameCapitalizer != null;
                        }
                        else if (!Options.UseNullableTypes)
                        {
                            if (Options.EnableDataBinding)
                            {
                                property.SetStatements.Add(new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "RaisePropertyChanged", new CodePrimitiveExpression(property.Name)));
                            }

                            capitalizeProperty = Options.PropertyNameCapitalizer != null;
                        }
                        else
                        {
                            capitalizeProperty = false;
                        }

                        if (capitalizeProperty)
                        {
                            var newName = Options.PropertyNameCapitalizer.Capitalize(property.Name);
                            if (newName != property.Name)
                            {
                                bool attributed = false;
                                foreach (CodeAttributeDeclaration attribute in property.CustomAttributes)
                                {
                                    switch (attribute.Name)
                                    {
                                        case "System.Xml.Serialization.XmlAttributeAttribute":
                                            attributed = true;
                                            attribute.Arguments.Add(new CodeAttributeArgument { Name = "", Value = new CodePrimitiveExpression(property.Name) });
                                            break;

                                        case "System.Xml.Serialization.XmlIgnoreAttribute":
                                        case "System.Xml.Serialization.XmlElementAttribute":
                                        case "System.Xml.Serialization.XmlArrayItemAttribute":
                                            attributed = true;
                                            break;
                                    }
                                }

                                if (!attributed)
                                    property.CustomAttributes.Add(new CodeAttributeDeclaration("System.Xml.Serialization.XmlElementAttribute", new CodeAttributeArgument { Name = "", Value = new CodePrimitiveExpression(property.Name) }));
                                property.Name = newName;
                            }
                        }
                    }
                }
            }

            foreach (var rt in removedTypes)
                codeNamespace.Types.Remove(rt);
        }

        private static string GetFieldName(string p, string suffix = null)
        {
            return p.Substring(0, 1).ToLower() + p.Substring(1) + suffix;
        }
    }
}
